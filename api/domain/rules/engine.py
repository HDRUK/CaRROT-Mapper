from data.models import Concept, ScanReportConcept

import logging
import serializers


logger = logging.getLogger(__name__)


class Concept2OMOP:

    @staticmethod
    def get_rules_by_scan_report_concept(scan_report_concept_id):

        logger.info("scan_report_concept_id: {}".format(scan_report_concept_id))

        _scan_report_concept = ScanReportConcept.objects.get(pk=scan_report_concept_id)

        logger.info("concept_id: {}".format(_scan_report_concept.concept.concept_id))

        _concept = Concept.objects.get(concept_id=_scan_report_concept.concept.concept_id)

        serializer = serializers.Concept(_concept)

        concept = serializer.data

        if concept.get('domain_id') == 'Condition':
            """
            https://ohdsi.github.io/TheBookOfOhdsi/CommonDataModel.html#conditionOccurrence

            condition_occurrence_id: This is typically an autogenerated value creating a unique identifier for each record.
            person_id: This is a foreign key to Laura’s record in the PERSON table and links PERSON to CONDITION_OCCURRENCE.
            condition_concept_id: A foreign key referring to the SNOMED code 266599000: 194696.
            condition_start_date: The date when the instance of the Condition is recorded.
            condition_source_value: This is the original source value representing the Condition. In Lauren’s case of dysmenorrhea the SNOMED code for that Condition is stored here, while the Concept representing the code went to the CONDITION_SOURCE_CONCEPT_ID and the Standard Concept mapped from that is stored in the CONDITION_CONCEPT_ID field.
            condition_source_concept_id: If the condition value from the source is coded using a vocabulary that is recognized by OHDSI, the concept ID that represents that value would go here. In the example of dysmennorhea the source value is a SNOMED code so the Concept representing that code is 194696. In this case it has the same value as the CONDITION_CONCEPT_ID field.
            """
            pass

        return concept


def create_rule():
    pass


def generate(self, request):
    omop_lookup = OMOPDetails()

    pk = self.kwargs.get("pk")

    # retrieve old ones (dates and person ids)
    # self.retrieve(request,pk)

    # do the rest... automatic lookup based on concept id

    scan_report = ScanReport.objects.get(pk=pk)

    # this is taking a long time to run/filter
    # find all fields that have been mapped with a concept id (>=0, default=-1)
    fields = ScanReportField.objects.filter(
        scan_report_table__scan_report=scan_report
    )
    # find fields that have a concept_id set,
    # OR find fields that have at least one value with a concept_id set
    fields = fields.filter(scanreportvalue__conceptID__gte=0) | fields.filter(
        concept_id__gte=0
    )

    # make unique
    fields = fields.distinct()

    #get unique source tables that are used
    source_tables = []
    for field in fields:
        source_table = field.scan_report_table
        source_tables.append(source_table)
    source_tables = list(set(source_tables))

    #call a check to firstly validate that person_ids have been set
    #in all the source tables that we actually use
    if not self.validate_person_ids(request,source_tables):
        return 

    # loop over found fields
    for field in fields:
        # get the field and associated table
        source_field = field
        source_table = field.scan_report_table

        # add info here

        # if the source field (column) has a concept_id set, use this..
        if source_field.concept_id >= 0:
            concepts = source_field.concept_id
        # otherwise find all field values with a concept_id set
        else:
            values = field.scanreportvalue_set.all().filter(conceptID__gte=0)

            # map the source value to the raw value
            concepts = {value.value: value.conceptID for value in values}

        # use the OmopDetails class to look up rules for these concepts
        try:
            rules_set = omop_lookup.get_rules(concepts)
        except Exception as e:
            # need to handle this better
            # print (e)
            messages.warning(request, e)
            # print (f"{field} failed")
            continue

        # temp hack/filter!!
        allowed_destination_tables = [
            "person",
            "condition_occurrence",
            "observation",
            "measurement",
        ]

        # loop over the destination and rule set for each domain found
        for destination_table, rules in rules_set.items():
            # temp hack to stop generating rules for the 'big 4'
            if destination_table not in allowed_destination_tables:
                continue

            for destination_field, term_mapping in rules.items():
                try:
                    omop_field = OmopField.objects.get(
                        table__table=destination_table, field=destination_field
                    )
                except Exception as err:
                    # remove message warnings about these now
                    # rules are automatically generated for:
                    # <domain>_source_value, <domain>_source_concept_id and <domain>_concept_id
                    # sometimes one of these might not exist, e.g. for specimen
                    # do not make a warning about this
                    if all(
                        x not in destination_field
                        for x in [
                            "_source_value",
                            "_source_concept_id",
                            "_concept_id",
                        ]
                    ):
                        messages.warning(
                            request,
                            f"{destination_table}::{destination_field} is somehow misssing??",
                        )
                    continue

                # create a new model
                mapping, created = StructuralMappingRule.objects.update_or_create(
                    scan_report=scan_report,
                    omop_field=omop_field,
                    source_table=source_table,
                    source_field=source_field,
                    term_mapping=json.dumps(
                        term_mapping, indent=6
                    ),  # convert dict to str,
                    approved=True,
                )
                mapping.save()

                # add mapping for person id
                # find the field in the table that is marked as person_d
                person_id_source_field = self.find_person_id(source_table)
                # get the associated OmopField Object (aka destination_table::person_id)
                person_id_omop_field = OmopField.objects.get(
                    table__table=destination_table, field="person_id"
                )
                # create/update a new rule for this
                # - this is going to be called multiple times needlessly,
                #  it could be broken out of this loop
                #  "update" should save us need to check if already exists
                mapping, created = StructuralMappingRule.objects.update_or_create(
                    scan_report=scan_report,
                    omop_field=person_id_omop_field,
                    source_table=source_table,
                    source_field=person_id_source_field,
                    term_mapping=None,
                    approved=True,
                )
                mapping.save()
                try:
                    primary_date_source_field = self.find_date_event(destination_table,source_table)
                except KeyError:
                    messages.error(request,f"No implementation for date-event for {destination_table} yet")
                    
                if primary_date_source_field is None:
                    messages.error(request,f"Failed to generate rules. You need to set an event date for {destination_table} in table {source_table}.")
                    self.clean()
                    return

                # this is just looking up a dictionary in the OmopDetails() class
                # e.g. { "person":["birth_datetime"]... }
                # this could easily be in MappingPipelines
                date_omop_fields = omop_lookup.get_date_fields(
                    omop_field.table.table
                )
                #loop over all returned
                #most will return just one
                #in the case of condition_occurrence, return start and end
                for date_omop_field in date_omop_fields:
                    # get the actual omop field object
                    date_omop_field = OmopField.objects.get(
                        table__table=destination_table, field=date_omop_field
                    )
                    
                    # make another mapping for this date object
                    mapping, created = StructuralMappingRule.objects.update_or_create(
                        scan_report=scan_report,
                        omop_field=date_omop_field,
                        source_table=source_table,
                        source_field=primary_date_source_field,
                        term_mapping=None,
                        approved=True,
                    )
                    mapping.save()
                # loop over dates to be added
            # loop over rules
        # loop over rules set
    # loop over all fields containing a concept id


def download_structural_mapping(self, request, return_type="json"):
    pk = self.kwargs.get("pk")

    scan_report = ScanReport.objects.get(pk=pk)

    rules = StructuralMappingRule.objects.filter(scan_report=scan_report)
    # .order_by('omop_field__table','omop_field__field','source_table__name','source_field__name')

    outputs = []

    for rule in rules:
        # if these havent been defined, skip.....
        if rule.source_table is None:
            continue
        if rule.source_field is None:
            continue
        # skip if the rule hasnt been approved
        if not rule.approved:
            continue

        output = {}
        output["rule_id"] = rule.id
        output["destination_table"] = rule.omop_field.table.table
        output["destination_field"] = rule.omop_field.field

        output["source_table"] = rule.source_table.name
        output["source_field"] = rule.source_field.name
        output["source_field_indexer"] = rule.source_field.is_patient_id

        # this needs to be updated if there is a coding system
        output["coding_system"] = None  # "user defined")

        output["term_mapping"] = None
        if rule.term_mapping:
            output["term_mapping"] = json.loads(rule.term_mapping)

        # need to implement multiple operations, one day
        operations = None
        if rule.operation and rule.operation != "NONE":
            operations = [rule.operation]
        output["operations"] = operations
        outputs.append(output)

    if len(outputs) == 0:
        messages.error(
            request,
            "Can't download or create json. Most likely because nothing has been approved.",
        )
        return redirect(request.path)

    # define the name of the output file
    fname = f"{scan_report.data_partner}_{scan_report.dataset}_structural_mapping.{return_type}"

    if return_type == "svg":
        fname = (
            f"{scan_report.data_partner}"
            f"_{scan_report.dataset}_structural_mapping.json"
        )

        tables = None
        table = self.kwargs.get("omop_table")
        if table is not None:
            tables = [table]

        source_tables = None
        source_table = self.kwargs.get("source_table")
        if source_table is not None:
            source_tables = [source_table]

        outputs = self.get_final_json(
            outputs, tables=tables, source_tables=source_tables
        )

        svg_output = self.json_to_svg(outputs["cdm"])

        return HttpResponse(svg_output, content_type="image/svg+xml")

    elif return_type == "json":
        outputs = self.get_final_json(outputs)
        response = HttpResponse(json.dumps(outputs,indent=6),content_type='application/json')
        response['Content-Disposition'] = f'attachment; filename="{fname}"'
        return response
    else:
        # implement other return types if needed
        return redirect(request.path)


def json_to_svg(self, data):
    # return dag.make_dag(data)
    pass


# need a quality check if multiple date events are found in the table
def find_date_event(self,destination_table,source_table):
    lookup = {
        'person':'birth_date',
        'measurement':'measurement_date',
        'condition_occurrence':'condition_date',
        'observation':'observation_date'
    }

    field = lookup[destination_table]

    return getattr(source_table,field)


def find_person_id(self, source_table):
    return source_table.person_id


def validate_person_ids(self,request,source_tables):
    is_valid = True
    #loop over source_tables looking for person_ids
    for table in source_tables:
        if table.person_id == None:
            messages.error(request,f"Cannot generate rules. Table \"{table}\" is used but you have not set the person_id.")
            is_valid = False
            
    return is_valid


def get_person_id_mapping(self):
    pk = self.kwargs.get("pk")
    patient_id_fields = ScanReportField.objects.filter(
        scan_report_table__scan_report=pk
    ).filter(is_patient_id=True)

    patient_id_map = {
        patient_field.scan_report_table.name: patient_field.name
        for patient_field in patient_id_fields
    }

    return patient_id_map


def post(self, request, *args, **kwargs):
    #
    if request.POST.get("download-sm") is not None:
        return self.download_structural_mapping(request)
    elif request.POST.get("generate") is not None:
        self.generate(request)
        return redirect(request.path)
    elif request.POST.get("clean") is not None:
        self.clean()
        return redirect(request.path)
    elif request.POST.get("svg") is not None:
        return self.download_structural_mapping(request, return_type="svg")
    else:
        super().post(request, *args, **kwargs)
        pass

    return redirect(request.path)


def get_final_json(self, _mapping_data, tables=None, source_tables=None):

    _id_map = self.get_person_id_mapping()

    # these two inputs shouldnt be so complicated
    # it's because _mapping_data is read by pd.read_json(blah)
    # and _id_map is read by json.loads(open(blah))
    #
    # all because with this function
    # you can input these are paths to files

    f_mapping = StringIO(json.dumps(_mapping_data))
    f_ids = StringIO(json.dumps(_id_map))

    structural_mapping = mapping_pipeline_helpers.StructuralMapping.to_json(
        f_mapping,
        f_ids,
        filter_destination_tables=tables,
        filter_source_tables=source_tables,
    )

    return structural_mapping

